
btConnector

 // 액션에 대한 브로드캐스트 업데이트
    private void broadcastUpdate(final String action) {
        final Intent intent = new Intent(action);
        Log.d(TAG, "broadcastUpdate: " + action);
//        mLocalBroadcastManager.sendBroadcast(intent);
    }

    // 데이터에 대한 브로드캐스트 업데이트
    private void broadcastUpdate(final String action,
                                 final BluetoothGattCharacteristic characteristic) {
        final Intent intent = new Intent(action);
// 데이터 처리 및 업데이트
//        Log.d(TAG, "broadcastUpdate: "+mLocalBroadcastManager);
        final byte[] data = characteristic.getValue();
        if (data != null && data.length > 1) {
            Log.d(TAG, "broadcastUpdate: " + action);
            Log.d(TAG, "broadcastUpdate: " + new String(data));
            Log.d(TAG, "broadcastUpdate: " + data.length);
            HashMap<String, String> extractedData = extractData(new String(data, StandardCharsets.UTF_8));
            intent.putExtra("heart", extractedData.get("hr"));
            intent.putExtra("temp", extractedData.get("tp"));
            intent.putExtra("accident", extractedData.get("ac"));
        }

//        mLocalBroadcastManager.sendBroadcast(intent);
    }

    데이터 처리에 대한 메소드 불용하여
    public HashMap<String, String> extractData(@NotNull String data) {


            HashMap<String, String> extractedData = new HashMap<>();

            String[] items = data.split(",");
            Log.d(TAG, "extractData: " + items.length);

            for (int i = 0; i < items.length; i += 2) {
                extractedData.put(items[i], items[i + 1]);
            }

            return extractedData;
        }
gatt 콜백

 private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
        @SuppressLint("MissingPermission")
        @Override // 커넥트 상태 업데이트
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            String intentAction;
            if (newState == BluetoothProfile.STATE_CONNECTED) {
                intentAction = BluetoothAttributes.ACTION_GATT_CONNECTED;
                mConnectionState = BluetoothAttributes.STATE_CONNECTED;
                broadcastUpdate(intentAction);
                Log.i(TAG, "Connected to GATT server.");
                // Attempts to discover services after successful connection.
                Log.i(TAG, "Attempting to start service discovery:" +
                        mBluetoothGatt.discoverServices());

                Log.d(TAG, "onConnectionStateChange: " + gatt.getDevice().getName());


            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                intentAction = BluetoothAttributes.ACTION_GATT_DISCONNECTED;
                mConnectionState = BluetoothAttributes.STATE_DISCONNECTED;
                Log.i(TAG, "Disconnected from GATT server.");
                broadcastUpdate(intentAction);

            }
        }

        @SuppressLint("MissingPermission")
        @Override // 블루투스 기기에서 넘어오는 서비스 확인
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                broadcastUpdate(BluetoothAttributes.ACTION_GATT_SERVICES_DISCOVERED);

                // 캐릭터 노티파이 설정
                BluetoothGattCharacteristic characteristic =
                        gatt.getService(UUID.fromString(BluetoothAttributes.SERVICE_UUID))
                                .getCharacteristic(UUID.fromString(BluetoothAttributes.CHARACTERISTIC_UUID));
                setCharacteristicNotification(characteristic, true);
                Log.d(TAG, "onServicesDiscovered: ");
            } else {
                Log.w(TAG, "onServicesDiscovered received: " + status);
            }
        }

        @Override // 데이터 읽을 시
        public void onCharacteristicRead(BluetoothGatt gatt,
                                         BluetoothGattCharacteristic characteristic,
                                         int status) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
//                broadcastUpdate(BluetoothAttributes.ACTION_DATA_AVAILABLE, characteristic);
                Log.d(TAG, "onCharacteristicRead: "+characteristic.getUuid());
            }
        }

        @Override// 노티파이 데이터 읽을시
        public void onCharacteristicChanged(BluetoothGatt gatt,
                                            BluetoothGattCharacteristic characteristic) {
//            broadcastUpdate(BluetoothAttributes.ACTION_DATA_AVAILABLE, characteristic);
            if(characteristic.getValue().length>1){// byte가 0 이 되는 경우가 있음
            repository.insertData(handleData(characteristic));
            }

        }
    };
불용하여 빼버림
 @SuppressLint("MissingPermission")
    public void readCharacteristic(BluetoothGattCharacteristic characteristic) {

        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
            Log.w(TAG, "BluetoothAdapter not initialized");
            return;
        }
        mBluetoothGatt.readCharacteristic(characteristic);
    }

     // 생성자에서 컨텍스트 초기화
        public BluetoothConnector(Context context, BluetoothAdapter adapter, BluetoothRepository repository) {
            this.mContext = context;
            Log.d(TAG, "BluetoothConnector: " + adapter);
            this.mBluetoothAdapter = adapter;
            this.repository = repository;
    //        this.mLocalBroadcastManager = LocalBroadcastManager.getInstance(context);
    //        Log.d(TAG, "BluetoothConnector: "+mLocalBroadcastManager);
        }


        private LocalBroadcastManager mLocalBroadcastManager;